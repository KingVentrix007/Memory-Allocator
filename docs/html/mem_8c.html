<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Memeroy Allocator: lowlevel/mem.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Memeroy Allocator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_26cd47652b16d197ebc64ecf415996b2.html">lowlevel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mem.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory Allocation Implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;mem.h&quot;</code><br />
<code>#include &quot;internal.h&quot;</code><br />
<code>#include &quot;mem_config.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a53bcc9c1f4fe098b102b72a97af1cb38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a53bcc9c1f4fe098b102b72a97af1cb38">print_node_info</a> (const <a class="el" href="structNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:a53bcc9c1f4fe098b102b72a97af1cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints information about a given node.  <a href="mem_8c.html#a53bcc9c1f4fe098b102b72a97af1cb38">More...</a><br /></td></tr>
<tr class="separator:a53bcc9c1f4fe098b102b72a97af1cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c501aea02a6ff74414bba87cd076113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a4c501aea02a6ff74414bba87cd076113">init_memory_allocation</a> (void *start_addr, int size)</td></tr>
<tr class="memdesc:a4c501aea02a6ff74414bba87cd076113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes memory allocation.  <a href="mem_8c.html#a4c501aea02a6ff74414bba87cd076113">More...</a><br /></td></tr>
<tr class="separator:a4c501aea02a6ff74414bba87cd076113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9a0e78f9993c8f45e8ccaea7f14dd5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a7b9a0e78f9993c8f45e8ccaea7f14dd5">sys_allocate_memory</a> (int size)</td></tr>
<tr class="memdesc:a7b9a0e78f9993c8f45e8ccaea7f14dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a consecutive bunch of memory blocks and updates the linked list.  <a href="mem_8c.html#a7b9a0e78f9993c8f45e8ccaea7f14dd5">More...</a><br /></td></tr>
<tr class="separator:a7b9a0e78f9993c8f45e8ccaea7f14dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406fd90a3f95c858165853e109fe7271"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a406fd90a3f95c858165853e109fe7271">sys_free_memory</a> (const void *addr)</td></tr>
<tr class="memdesc:a406fd90a3f95c858165853e109fe7271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory blocks starting from the specified address and updates the linked list. Also removes the corresponding block from the memory_allocations list and sorts it.  <a href="mem_8c.html#a406fd90a3f95c858165853e109fe7271">More...</a><br /></td></tr>
<tr class="separator:a406fd90a3f95c858165853e109fe7271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb60350e8b0887063d3976054b6769"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#aa2cb60350e8b0887063d3976054b6769">sys_reallocate_memory</a> (void *addr, int old_size, int new_size)</td></tr>
<tr class="memdesc:aa2cb60350e8b0887063d3976054b6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory for a previously allocated block and updates the linked list. !! WARNING !!: This function deallocates the addr value.  <a href="mem_8c.html#aa2cb60350e8b0887063d3976054b6769">More...</a><br /></td></tr>
<tr class="separator:aa2cb60350e8b0887063d3976054b6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e1848dd1f6ac2ef3a214ef6b157af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a18e1848dd1f6ac2ef3a214ef6b157af2">print_memory_info</a> ()</td></tr>
<tr class="memdesc:a18e1848dd1f6ac2ef3a214ef6b157af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints information about the memory.  <a href="mem_8c.html#a18e1848dd1f6ac2ef3a214ef6b157af2">More...</a><br /></td></tr>
<tr class="separator:a18e1848dd1f6ac2ef3a214ef6b157af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fdfeaa16470a038585904910c0973"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a350fdfeaa16470a038585904910c0973">init_memory_region</a> (void *start_addr, size_t size)</td></tr>
<tr class="memdesc:a350fdfeaa16470a038585904910c0973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the memory region for allocation.  <a href="mem_8c.html#a350fdfeaa16470a038585904910c0973">More...</a><br /></td></tr>
<tr class="separator:a350fdfeaa16470a038585904910c0973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edaee3ea2b783507029f348655a1374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a6edaee3ea2b783507029f348655a1374">extend_allocation_space</a> (void *extra_region, size_t size)</td></tr>
<tr class="memdesc:a6edaee3ea2b783507029f348655a1374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the allocation space by initializing new nodes in the extra region.  <a href="mem_8c.html#a6edaee3ea2b783507029f348655a1374">More...</a><br /></td></tr>
<tr class="separator:a6edaee3ea2b783507029f348655a1374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcde9dfb4a3501997defaf0629f3729f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#afcde9dfb4a3501997defaf0629f3729f">get_memory_size</a> (const void *ptr)</td></tr>
<tr class="memdesc:afcde9dfb4a3501997defaf0629f3729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the allocated memory block pointed to by ptr.  <a href="mem_8c.html#afcde9dfb4a3501997defaf0629f3729f">More...</a><br /></td></tr>
<tr class="separator:afcde9dfb4a3501997defaf0629f3729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65400312383b6112b13d348f3e6516e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a65400312383b6112b13d348f3e6516e0">memcleanup</a> ()</td></tr>
<tr class="memdesc:a65400312383b6112b13d348f3e6516e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the memory by resetting the allocated nodes.  <a href="mem_8c.html#a65400312383b6112b13d348f3e6516e0">More...</a><br /></td></tr>
<tr class="separator:a65400312383b6112b13d348f3e6516e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528f68e26e73ebabf3a07b18274948a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a528f68e26e73ebabf3a07b18274948a8">buffer_overflow_detector</a> ()</td></tr>
<tr class="memdesc:a528f68e26e73ebabf3a07b18274948a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects buffer overflows by checking for non-zero bytes in the allocated memory regions.  <a href="mem_8c.html#a528f68e26e73ebabf3a07b18274948a8">More...</a><br /></td></tr>
<tr class="separator:a528f68e26e73ebabf3a07b18274948a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e9408db729538ad41becff1dfefeee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a66e9408db729538ad41becff1dfefeee">memory_leak_detector</a> ()</td></tr>
<tr class="memdesc:a66e9408db729538ad41becff1dfefeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to detect memory leaks.  <a href="mem_8c.html#a66e9408db729538ad41becff1dfefeee">More...</a><br /></td></tr>
<tr class="separator:a66e9408db729538ad41becff1dfefeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675d7a0529f784a7c298b19a64e7d08e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a675d7a0529f784a7c298b19a64e7d08e">find_dangling_pointer</a> ()</td></tr>
<tr class="memdesc:a675d7a0529f784a7c298b19a64e7d08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds potential dangling pointers by checking for non-zero data in memory regions that do not border an allocated region.  <a href="mem_8c.html#a675d7a0529f784a7c298b19a64e7d08e">More...</a><br /></td></tr>
<tr class="separator:a675d7a0529f784a7c298b19a64e7d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0067276a6f470f8744cde11001611b"><td class="memItemLeft" align="right" valign="top"><a id="a1e0067276a6f470f8744cde11001611b"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>run_checks</b> ()</td></tr>
<tr class="separator:a1e0067276a6f470f8744cde11001611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aca28c5c6565ca8703cf66b756b53b7ee"><td class="memItemLeft" align="right" valign="top"><a id="aca28c5c6565ca8703cf66b756b53b7ee"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>memory_region</b></td></tr>
<tr class="separator:aca28c5c6565ca8703cf66b756b53b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e782bcef4eab440683366fe6438b980"><td class="memItemLeft" align="right" valign="top"><a id="a4e782bcef4eab440683366fe6438b980"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>end_of_node_region</b></td></tr>
<tr class="separator:a4e782bcef4eab440683366fe6438b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b2a6f19301c47e33923a1e6c9eee1a"><td class="memItemLeft" align="right" valign="top"><a id="ab6b2a6f19301c47e33923a1e6c9eee1a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>memory_region_end</b></td></tr>
<tr class="separator:ab6b2a6f19301c47e33923a1e6c9eee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec70fceae7136c5845681ca15efba4"><td class="memItemLeft" align="right" valign="top"><a id="a39ec70fceae7136c5845681ca15efba4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>memory_allocation_error_code</b></td></tr>
<tr class="separator:a39ec70fceae7136c5845681ca15efba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d0831f9ba96575fe7e9e4bd0b906ed"><td class="memItemLeft" align="right" valign="top"><a id="a13d0831f9ba96575fe7e9e4bd0b906ed"></a>
<a class="el" href="structFreeZone.html">FreeZone</a>&#160;</td><td class="memItemRight" valign="bottom"><b>free_zones</b> [MAX_CASHED_ALLOCATIONS] = {}</td></tr>
<tr class="separator:a13d0831f9ba96575fe7e9e4bd0b906ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4a881a56a62ab9c5d60bc975165b0"><td class="memItemLeft" align="right" valign="top"><a id="a14a4a881a56a62ab9c5d60bc975165b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>free_zone_count</b> = 0</td></tr>
<tr class="separator:a14a4a881a56a62ab9c5d60bc975165b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory Allocation Implementation. </p>
<dl class="section author"><dt>Author</dt><dd>Tristan Kuhn </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Tristan Kuhn </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023-09-15 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a528f68e26e73ebabf3a07b18274948a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528f68e26e73ebabf3a07b18274948a8">&#9670;&nbsp;</a></span>buffer_overflow_detector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_overflow_detector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects buffer overflows by checking for non-zero bytes in the allocated memory regions. </p>
<p>This function is responsible for detecting buffer overflowss by checking for non-zero bytes in the allocated memory regions. It iterates through the linked list of nodes, checks if the memory region is allocated or not, and if not, it copies the memory region to a temporary buffer and checks for non-zero bytes. If non-zero bytes are found, a log message is printed indicating a possible buffer overflows. The function also keeps track of the last allocated memory block pointer for reference. The logic involves iterating through the linked list, copying memory regions, and checking for non-zero bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if no buffer overflows is detected, -1 if a possible buffer overflows is found. </dd></dl>

</div>
</div>
<a id="a6edaee3ea2b783507029f348655a1374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edaee3ea2b783507029f348655a1374">&#9670;&nbsp;</a></span>extend_allocation_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extend_allocation_space </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extra_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the allocation space by initializing new nodes in the extra region. </p>
<p>This function is responsible for extending the allocation space by initializing new nodes in the extra region. It takes a pointer to the extra region and the size of the extra region as parameters. The function currently has a warning indicating that it is broken and needs fixing. The logic of the function involves finding the last node in the existing list, initializing new nodes in the extended allocation space using the <code>init_memory_region</code> function, updating the next pointer of the last node to point to the first new node, and updating the end_of_node_region to the end of the extended node region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extra_region</td><td>Pointer to the extra region for extending the allocation space. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the extra region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<p>CURRENTLY BROKEN</p>

</div>
</div>
<a id="a675d7a0529f784a7c298b19a64e7d08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d7a0529f784a7c298b19a64e7d08e">&#9670;&nbsp;</a></span>find_dangling_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_dangling_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds potential dangling pointers by checking for non-zero data in memory regions that do not border an allocated region. </p>
<p>This function iterates through the linked list of nodes, checks if the memory region is allocated or not, and if not, it checks for non-zero bytes in the memory region. If non-zero bytes are found and the memory region does not border an allocated region, it logs a message indicating a potential dangling pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if no potential dangling pointers are found, -1 if potential issues are detected. </dd></dl>

</div>
</div>
<a id="afcde9dfb4a3501997defaf0629f3729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcde9dfb4a3501997defaf0629f3729f">&#9670;&nbsp;</a></span>get_memory_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_memory_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of the allocated memory block pointed to by ptr. </p>
<p>This function is responsible for retrieving the size of the allocated memory block pointed to by ptr. It takes a pointer to the memory block as a parameter. The function iterates through the linked list of nodes, comparing the addresses, and returns the size of the allocated memory block if found. If the memory block is not found or not allocated, a log message is printed, and -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the memory block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the allocated memory block, or -1 if it is not found or not allocated. </dd></dl>

</div>
</div>
<a id="a4c501aea02a6ff74414bba87cd076113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c501aea02a6ff74414bba87cd076113">&#9670;&nbsp;</a></span>init_memory_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_memory_allocation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes memory allocation. </p>
<p>This function is responsible for initializing memory allocation. It takes a starting address and size as parameters. The function calls the <code>init_memory_region</code> function to initialize the memory region. Additionally, there are commented lines of code that suggest allocating memory for <code>memory_allocations</code>, but they are currently not being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_addr</td><td>The starting address of the memory region. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a350fdfeaa16470a038585904910c0973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350fdfeaa16470a038585904910c0973">&#9670;&nbsp;</a></span>init_memory_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* init_memory_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the memory region for allocation. </p>
<p>This function is responsible for initializing the memory region for allocation. It takes the starting address of the memory region and the size of the memory region as parameters. The function calculates the number of nodes based on the size of each node and the total size of the memory region. It then calculates the size needed for the nodes and the size available for actual allocation. The function initializes the first node and sets the end of the node region and the start of the allocation region. It then iterates through the rest of the nodes, setting their addresses, sizes, and other fields. If the available space for allocation is exceeded, the function adjusts the number of blocks used and logs the available bytes. Finally, the function returns the end address of the node region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_addr</td><td>The starting address of the memory region. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end address of the node region. </dd></dl>

</div>
</div>
<a id="a65400312383b6112b13d348f3e6516e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65400312383b6112b13d348f3e6516e0">&#9670;&nbsp;</a></span>memcleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memcleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the memory by resetting the allocated nodes. </p>
<p>This function is responsible for cleaning up the memory by resetting the allocated nodes. It iterates through the linked list of nodes, sets the allocated flag to false, clears the memory of the node, sets the size and number of blocks used to 0, and moves to the next node.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a66e9408db729538ad41becff1dfefeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e9408db729538ad41becff1dfefeee">&#9670;&nbsp;</a></span>memory_leak_detector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memory_leak_detector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to detect memory leaks. </p>
<p>This function iterates through a linked list of memory regions and checks for memory leaks. It logs information about allocated memory regions and their sizes.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a18e1848dd1f6ac2ef3a214ef6b157af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e1848dd1f6ac2ef3a214ef6b157af2">&#9670;&nbsp;</a></span>print_memory_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_memory_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints information about the memory. </p>
<p>This function is responsible for printing information about the memory. It takes a printing option as a parameter, which determines the level of detail in the output. The function iterates through the linked list of nodes and prints various details about each node, such as its address, size, allocated status, first block status, and the number of blocks used. Additionally, the function calculates and prints the amount of free space between allocated blocks. The level of detail in the output is determined by the printing option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_option</td><td>Determines the printing option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a53bcc9c1f4fe098b102b72a97af1cb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bcc9c1f4fe098b102b72a97af1cb38">&#9670;&nbsp;</a></span>print_node_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_node_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints information about a given node. </p>
<p>This function prints various information about a given node, such as its address, size, allocated status, first block status, and the number of blocks used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to the node for which information needs to be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b9a0e78f9993c8f45e8ccaea7f14dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9a0e78f9993c8f45e8ccaea7f14dd5">&#9670;&nbsp;</a></span>sys_allocate_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_allocate_memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a consecutive bunch of memory blocks and updates the linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of memory to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The starting address of the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a id="a406fd90a3f95c858165853e109fe7271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406fd90a3f95c858165853e109fe7271">&#9670;&nbsp;</a></span>sys_free_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_free_memory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory blocks starting from the specified address and updates the linked list. Also removes the corresponding block from the memory_allocations list and sorts it. </p>
<p>This function is responsible for freeing memory blocks starting from the specified address and updating the linked list accordingly. It takes the address of the memory to free as a parameter. The function searches for the node corresponding to the given address in the linked list. If the node is found and the memory is allocated, the function marks the memory blocks as free in the linked list. It also updates the necessary fields in the nodes. Additionally, the function creates a <a class="el" href="structFreeZone.html">FreeZone</a> structure to store information about the freed memory block, and adds it to the free_zones array. If the address is not found or the memory is not allocated, a log message is printed. The function returns NULL after freeing the memory blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address of the memory to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL after freeing the memory blocks, or the original address if it is not found or not allocated. </dd></dl>

</div>
</div>
<a id="aa2cb60350e8b0887063d3976054b6769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb60350e8b0887063d3976054b6769">&#9670;&nbsp;</a></span>sys_reallocate_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sys_reallocate_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory for a previously allocated block and updates the linked list. !! WARNING !!: This function deallocates the addr value. </p>
<p>This function is responsible for reallocating memory for a previously allocated block and updating the linked list accordingly. It takes the address of the memory block to reallocate, the current size of the memory block, and the new size to which the memory block should be reallocated. The function first checks for invalid parameters, such as when the old size exceeds the new size or when the address is NULL or out of range. If the parameters are valid, the function allocates new memory using the <code>sys_allocate_memory</code> function. It then checks if the allocation was successful, and if so, it copies the data from the old memory to the new memory using <code>memcpy</code>. Finally, the function frees the old memory using the <code>sys_free_memory</code> function and returns the new address of the reallocated memory block. If the reallocation fails, a log message is printed, and the function returns the original address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address of the memory block to reallocate. </td></tr>
    <tr><td class="paramname">old_size</td><td>The current size of the memory block in bytes. </td></tr>
    <tr><td class="paramname">new_size</td><td>The new size to which the memory block should be reallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new address of the reallocated memory block, or the original address if the reallocation fails. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
